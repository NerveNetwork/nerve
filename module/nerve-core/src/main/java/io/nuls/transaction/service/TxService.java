package io.nuls.transaction.service;

import io.nuls.base.data.NulsHash;
import io.nuls.base.data.Transaction;
import io.nuls.core.exception.NulsException;
import io.nuls.transaction.model.bo.Chain;
import io.nuls.transaction.model.bo.TxPackageWrapper;
import io.nuls.transaction.model.bo.TxRegister;
import io.nuls.transaction.model.bo.VerifyResult;
import io.nuls.transaction.model.dto.ModuleTxRegisterDTO;
import io.nuls.transaction.model.po.TransactionConfirmedPO;
import io.nuls.transaction.model.po.TransactionNetPO;

import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * @author: Charlie
 * @date: 2018/11/22
 */
public interface TxService {

    /**
     * Registration transaction
     * Register transaction
     *
     * @param chain
     * @param moduleTxRegisterDto
     * @return boolean
     */
    boolean register(Chain chain, ModuleTxRegisterDTO moduleTxRegisterDto);

    /**
     * Received a new transaction
     * Received a new transaction
     *
     * @param tx
     * @return boolean
     * @throws NulsException NulsException
     */
    void newBroadcastTx(Chain chain, TransactionNetPO tx);


    /**
     * New transactions generated by nodes,The transaction has been verified through validator and ledger verification,Can be placed in the queue for packaging and unconfirmed storage
     * @param chain
     * @param transaction
     * @throws NulsException
     */
    void newTx(Chain chain, Transaction transaction) throws NulsException;


    /**
     * Verify transactions
     * @param chain
     * @param tx
     * @return
     */
    VerifyResult verify(Chain chain, Transaction tx);

    /**
     * Basic transaction verification
     *
     * @param chain
     * @param tx
     * @param txRegister
     * @throws NulsException
     */
    void baseValidateTx(Chain chain, Transaction tx, TxRegister txRegister, Long height) throws NulsException;
    void baseValidateTx(Chain chain, Transaction tx, TxRegister txRegister) throws NulsException;

    /**
     * Get a transaction, first check the database from the confirmation transaction,
     * if not found, then query from the confirmed transaction
     *
     * Get a transaction, First, query in the unconfirmed transaction database, If not found, search from the confirmed transactions again
     *
     * @param chain chain
     * @param hash  tx hash
     * @return Transaction If not found, returnnull
     */
    TransactionConfirmedPO getTransaction(Chain chain, NulsHash hash);

    /**
     * Check if the transaction exists, first check in the unconfirmed database, and then check from the confirmed database
     * @param chain
     * @param hash
     * @return
     */
    boolean isTxExists(Chain chain, NulsHash hash);

    /**
     * Clean up the transaction foundation section
     * @param chain
     * @param tx
     */
    void baseClearTx(Chain chain, Transaction tx);

    /**
     * Delete a single invalid transaction from a verified unpackaged transaction
     *
     * @param chain
     * @param tx
     * @return
     */
    void clearInvalidTx(Chain chain, Transaction tx);

    /**
     * Delete a single invalid transaction from a verified unpackaged transaction
     * @param chain
     * @param tx
     * @param changeStatus
     */
    void clearInvalidTx(Chain chain, Transaction tx, boolean changeStatus);


    /**
     * Add the transaction back to the packaging queue
     * Trading Orphans(If there is any),Add to the verified transaction set,Sort in reverse order of removal,Then add the frontend of the queue to be packaged in sequence
     *
     * @param chain
     * @param txList      Verified transactions
     * @param orphanTxSet Orphan Trading
     */
    void putBackPackablePool(Chain chain, List<TxPackageWrapper> txList, Set<TxPackageWrapper> orphanTxSet);
    void putBackPackablePool(Chain chain, Set<TxPackageWrapper> orphanTxSet);

    /**
     * When adding orphan transactions back to the pending packaging queue, To determine how many times it has been added(Because it was verified to be an orphan transaction during the next packaging, it will be added back again), Once the threshold is reached, it will no longer be added back
     * @param chain
     * @param orphanTxSet
     * @param txPackageWrapper
     */
    void addOrphanTxSet(Chain chain, Set<TxPackageWrapper> orphanTxSet, TxPackageWrapper txPackageWrapper);

    /**
     * 1.Unified verification and generate
     * 2a:If there are no transactions that fail verification, end!!
     * 2b.When there are failed verifications,moduleVerifyMapFilter out transactions that do not pass.
     * 3.Re validate transactions in the same module that do not pass after the transaction(Including individualverifyandcoinData), execute again1.recursionï¼Ÿ
     *
     * @param moduleVerifyMap
     */
    List<String> txModuleValidatorPackable(Chain chain, Map<String, List<String>> moduleVerifyMap, List<TxPackageWrapper> packingTxList,
                                           Set<TxPackageWrapper> orphanTxSet, long height, long blockTime) throws NulsException;
}
