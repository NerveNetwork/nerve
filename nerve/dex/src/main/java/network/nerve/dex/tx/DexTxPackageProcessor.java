package network.nerve.dex.tx;

import io.nuls.base.data.CoinFrom;
import io.nuls.base.data.CoinTo;
import io.nuls.base.data.Transaction;
import io.nuls.base.protocol.ModuleTxPackageProcessor;
import io.nuls.core.constant.TxType;
import io.nuls.core.core.annotation.Autowired;
import io.nuls.core.core.annotation.Component;
import io.nuls.core.exception.NulsException;
import io.nuls.core.rpc.model.ModuleE;
import network.nerve.dex.context.DexErrorCode;
import network.nerve.dex.manager.DexService;
import network.nerve.dex.util.LoggerUtil;
import org.bouncycastle.util.encoders.Hex;

import java.io.IOException;
import java.util.*;

@Component(ModuleE.Constant.DEX)
public class DexTxPackageProcessor implements ModuleTxPackageProcessor {

    @Autowired
    private DexService dexService;

    @Override
    public Map<String, List<String>> packProduce(int chainId, List<Transaction> txs, int process, long height, long blockTime) throws NulsException {

        try {
            if (process == 0) {
                Map<String, List<Transaction>> map = dexService.doPacking(txs, blockTime, height, false);
                List<Transaction> txList = map.get("dealTxList");
                List<String> newlyList = new ArrayList<>();
                List<String> rmHashList = new ArrayList<>();
                if (txList.size() > 0) {
                    for (int i = 0; i < txList.size(); i++) {
                        newlyList.add(Hex.toHexString(txList.get(i).serialize()));
                    }
                }

                txList = map.get("removeTxList");
                if (txList.size() > 0) {
                    for (int i = 0; i < txList.size(); i++) {
                        rmHashList.add(txList.get(i).getHash().toHex());
                    }
                }

                Map<String, List<String>> packMap = new HashMap<>();
                packMap.put("newlyList", newlyList);
                packMap.put("rmHashList", rmHashList);

                return packMap;
            } else {
                //Batch verify all transactions in this module
                validateTxs(txs, blockTime, height);
                return null;
            }
        } catch (IOException e) {
            LoggerUtil.dexLog.error(e);
            throw new NulsException(DexErrorCode.FAILED);
        }
    }

    /**
     * When synchronizing blocks, batch verify all transactions in this module
     * The verification here only applies to the transaction records generated by the commission order. If the transaction records generated by the verification are different from
     * Verify Logic：
     * 1.Put block packaged transaction transactions into a collection
     * 2.Generate transaction transactions based on block packaged pending orders and place them in another set
     * 3.Compare whether the transactions in two sets are consistent
     *
     * @param txs
     */
    private void validateTxs(List<Transaction> txs, long blockTime, long height) throws NulsException {
        List<Transaction> dealTxList1 = new ArrayList<>();
        List<Transaction> dealTxList2;
        //If this packaging istxsCount Reg0, indicating that the block being packaged this time is an empty block
        //It is highly likely that the occurrence of packaging empty blocks is due to insufficient packaging time, so matching verification is not performed on transactions made with empty blocks
        boolean isEmpty = false;
        if (txs.isEmpty()) {
            isEmpty = true;
        }

        Transaction tx;
        for (int i = 0; i < txs.size(); i++) {
            tx = txs.get(i);
            if (tx.getType() == TxType.TRADING_DEAL) {
                dealTxList1.add(tx);
                txs.remove(i);
                i--;
            } else if (tx.getType() == TxType.ORDER_CANCEL_CONFIRM) {
                dealTxList1.add(tx);
                txs.remove(i);
                i--;
            }
        }
        //Generate transaction volume based on block packaged pending orders

        Map<String, List<Transaction>> map = dexService.doPacking(txs, blockTime, height, true);

        List<Transaction> removeTxList = map.get("removeTxList");
        if (!removeTxList.isEmpty()) {
            LoggerUtil.dexLog.error("--------batch validate dexTxs fail, have removeTxList ------------");
            LoggerUtil.dexLog.error("-------- block height：" + height);
            for (Transaction x : removeTxList) {
                LoggerUtil.dexLog.error("--------txHash:" + x.getHash().toHex() + ",type:" + x.getType());
            }
            throw new NulsException(DexErrorCode.SYNC_BATCH_VALIDATE_ERROR);
        }
        dealTxList2 = map.get("dealTxList");

        //Compare whether the transactions are consistent,If the current package is an empty block, this verification will not be performed
        if (dealTxList1.size() != dealTxList2.size() && !isEmpty) {
            LoggerUtil.dexLog.error("--------dealTxList validate fail Inconsistent comparison length ------------");
            LoggerUtil.dexLog.error("-------- block height：" + height);
            LoggerUtil.dexLog.error("--------dealTxList1.size:{}, dealTxList1.size:{}", dealTxList1.size(), dealTxList2.size());

            for (Transaction tx1 : dealTxList1) {
                LoggerUtil.dexLog.error("--------dealTxList1 from ------------");
                for (CoinFrom from : tx1.getCoinDataInstance().getFrom()) {
                    LoggerUtil.dexLog.error(from.toString());
                }

                LoggerUtil.dexLog.error("--------dealTxList1 to ------------");
                for (CoinTo to : tx1.getCoinDataInstance().getTo()) {
                    LoggerUtil.dexLog.error(to.toString());
                }
            }

            LoggerUtil.dexLog.error("---------------- ------------");
            for (Transaction tx1 : dealTxList2) {
                LoggerUtil.dexLog.error("--------dealTxList2 from ------------");
                for (CoinFrom from : tx1.getCoinDataInstance().getFrom()) {
                    LoggerUtil.dexLog.error(from.toString());
                }
                LoggerUtil.dexLog.error("--------dealTxList2 to ------------");
                for (CoinTo to : tx1.getCoinDataInstance().getTo()) {
                    LoggerUtil.dexLog.error(to.toString());
                }
            }
            throw new NulsException(DexErrorCode.SYNC_BATCH_VALIDATE_ERROR);
        }

        if (dealTxList1.size() == dealTxList2.size()) {
            for (int i = 0; i < dealTxList1.size(); i++) {
                if (!equals(dealTxList1.get(i), dealTxList2.get(i))) {
                    LoggerUtil.dexLog.error("--------dealTxList validate fail Inconsistent amounts ------------");
                    LoggerUtil.dexLog.error("-------- block height：" + height);


                    for (Transaction tx1 : dealTxList1) {
                        LoggerUtil.dexLog.error("--------dealTxList1 from ------------");
                        for (CoinFrom from : tx1.getCoinDataInstance().getFrom()) {
                            LoggerUtil.dexLog.error(from.toString());
                        }
                        LoggerUtil.dexLog.error("--------dealTxList1 to ------------");
                        for (CoinTo to : tx1.getCoinDataInstance().getTo()) {
                            LoggerUtil.dexLog.error(to.toString());
                        }
                    }

                    LoggerUtil.dexLog.error("---------------- ------------");

                    for (Transaction tx1 : dealTxList2) {
                        LoggerUtil.dexLog.error("--------dealTxList2 from ------------");
                        for (CoinFrom from : tx1.getCoinDataInstance().getFrom()) {
                            LoggerUtil.dexLog.error(from.toString());
                        }
                        LoggerUtil.dexLog.error("--------dealTxList2 to ------------");
                        for (CoinTo to : tx1.getCoinDataInstance().getTo()) {
                            LoggerUtil.dexLog.error(to.toString());
                        }
                    }
                    throw new NulsException(DexErrorCode.SYNC_BATCH_VALIDATE_ERROR);
                }
            }
        }
    }

    /**
     * Verify if two transactions are consistent
     *
     * @param tx1
     * @param tx2
     * @return
     */
    private boolean equals(Transaction tx1, Transaction tx2) {
        if (!Arrays.equals(tx1.getTxData(), tx2.getTxData())) {
            return false;
        }
        if (!Arrays.equals(tx1.getCoinData(), tx2.getCoinData())) {
            return false;
        }
        return true;
    }

    @Override
    public String getModuleCode() {
        return ModuleE.DX.abbr;
    }
}
